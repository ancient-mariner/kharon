/***********************************************************************
* This file is part of kharon <https://github.com/ancient-mariner/kharon>.
* Copyright (C) 2019-2022 Keith Godfrey
*
* kharon is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3.
*
* kharon is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with kharon.  If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <string.h>
#include <math.h>
#include "world_map.h"


// wrapper to strtok and strtof. returns 0 on success, errno on error
static int parse_next_value_f(
      /* in     */       char *str,
      /* in out */       char **save_ptr,
      /*    out */       double *val
      )
{
   char *tok = strtok_r(str, " \t", save_ptr);
   if (tok == NULL) {
      errno = ENOKEY;   // wrong error type, but it's something
   } else {
      errno = 0;
      *val = strtof(tok, NULL);
   }
   return errno;
}


// reads declination and gives approx declination and inclination
//    for given position. algorithm is stupid and assumes a planar
//    surface instead of sphere, so intermediate results can be
//    wonky (ie, when comparing points at long distance) but the
//    relevant comparisons are <1 deg apart, which is close enough
//    to flat that we don't have to do spherical math
// input file assumed to be generated by wmm/convert.py
// expected format: <lon> <lat> <decl> <incl> ...\n
int load_declination(
      /* in     */ const char *fname,
      /* in     */ const world_coordinate_type latlon,
      /*    out */       double *declination,
      /*    out */       double *inclination
      )
{
//int watch = 1;
//start:
   ;
   int rc = 1;
   // distance stored as squared -- we're only worried about relative
   //    computation so no need for tens of thousands of sqrt calls
   double max_dist2 = 10000.0;
   // reset longitude to be on -180,180 to match representation in
   //    declination file
   double longitude = latlon.lon;
   double latitude = latlon.lat;
   while (longitude > 180.0) {
      longitude -= 360.0;
   }
   // open declination file
   FILE *fp = fopen(fname, "r");
   if (!fp) {
      fprintf(stderr, "Unable to open '%s': %s\n", fname, strerror(errno));
      goto end;
   }
//if (watch == 1) {
//   printf("Decl search for %.4f,%.4f\n", longitude, latitude);
//}
   // fetch closest lat/lon declination value and use it
   char buf[BUF_LEN];
   char *save_ptr;
   uint32_t line_num = 0;
   while (fgets(buf, BUF_LEN, fp) != NULL) {
      line_num++;
      // get distance from specified point
      // longitude
      double lon;
      if (parse_next_value_f(buf, &save_ptr, &lon) != 0) {
         fprintf(stderr, "Error parsing longitude in %s, line %d: %s\n",
               fname, line_num, strerror(errno));
         goto end;
      }
      // latitude
      double lat;
      if (parse_next_value_f(NULL, &save_ptr, &lat) != 0) {
         fprintf(stderr, "Error parsing Latitude in %s, line %d: %s\n",
               fname, line_num, strerror(errno));
         goto end;
      }
      // if this lat,lon is closer than previously read value, use it
      // assume cylindrical projection for distance calculation. since
      //    comparison is relative, this shouldn't degrade accuracy
      //    significantly
      double dx = lon - longitude;
      if (fabs(dx) > 180.0) {
         // points are on opposite sides of date line. unwrap
         dx = 360.0 - fabs(dx);
      }
      double dy = lat - latitude;
      double dist2 = dx*dx + dy*dy;
//if (watch == 1) {
//   printf("  %.1f,%.1f   %.3f,%.3f = %.3f (%.3f)\n", lon, lat, dx, dy, sqrt(dist2), sqrt(max_dist2));
//}
      if (dist2 > max_dist2) {
         continue;
      }
//if (watch == 1) {
//   printf("    SET\n");
//}
      // declination
      if (parse_next_value_f(NULL, &save_ptr, declination) != 0) {
         fprintf(stderr, "Error parsing declination in %s, line %d: %s\n",
               fname, line_num, strerror(errno));
         goto end;
      }
      // inclination
      if (inclination != NULL) {
         if (parse_next_value_f(NULL, &save_ptr, inclination) != 0) {
            fprintf(stderr, "Error parsing inclination in %s, line %d: %s\n",
                  fname, line_num, strerror(errno));
            goto end;
         }
      }
      max_dist2 = dist2;
   }
   rc = 0;
end:
   if (fp != NULL) {
      fclose(fp);
   }
//if (watch == 1) {
//   exit(1);
//}
   // grid has spacing of 1 degree, so no coordinate should be more
   //    than 0.7 away from grid vertex. however, +90 and -90 lat are
   //    not plotted, so max distance from vertex is 1.0 if coord is
   //    at +/-90
   // make sure max dist is w/in expected bounds
   if (max_dist2 > 1.01) {
      fprintf(stderr, "### Data error -- lat %.3f  lon %.3f is %.3f away "
            "from closest grid point, which should be impossible "
            "(distance shouldn't " "exceed 1.0)\n", latlon.lat, latlon.lon,
            sqrt(max_dist2));
      // not much we can do about this if problem occurs in running app,
      //    as this library has no clue about logging
      // TODO move read_declination to main code line and log an error here
//watch = 1;
//goto start;
//exit(1);
   }
//printf("best dist is %.3f\n", sqrt(max_dist2));
//exit(0);
   return rc;
}


