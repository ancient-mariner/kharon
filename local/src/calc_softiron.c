/***********************************************************************
* This file is part of kharon <https://github.com/ancient-mariner/kharon>.
* Copyright (C) 2019-2022 Keith Godfrey
*
* kharon is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3.
*
* kharon is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with kharon.  If not, see <http://www.gnu.org/licenses/>.
***********************************************************************/
#include "pinet.h"
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <math.h>
#include <assert.h>
#include "lin_alg.h"
#include "dev_info.h"

// generate config files for mag correction, hard and soft iron

static char config_file_[STR_LEN] = { 0 };
static char template_file_[STR_LEN] = { 0 };
static char dev_dir_[STR_LEN] = { 0 };

static char host_name_[STR_LEN];
static char device_name_[STR_LEN];
static vector_type rot_;
static vector_type scale_;
static double gauss_;
char matrix_order_[STR_LEN];
vector_type offset_;

// derived values
static matrix_type softiron_;

#define SUPPORTED_VERSION   2.0

static void usage(const char *arg0)
{
   printf("Generate config files for mag correction\n");
   printf("Usage: %s -i <config-file> | -t <name>\n", arg0);
   printf("\n");
   printf("where:\n");
   printf("    -i    name of input config file\n");
   printf("    -t    generate template config file\n");
   printf("    -d    path of dev directory\n");
   printf("\n");
   exit(1);
}

static void parse_command_line(int argc, char *argv[])
{
   int opt;
   while ((opt = getopt(argc, argv, "d:i:t:")) != -1) {
      switch (opt) {
         case 'i':
            {
               if (config_file_[0])
                  usage(argv[0]);
               const char * name = optarg;
               strcpy(config_file_, name);
            }
            break;
         case 'd':
            {
               if (dev_dir_[0])
                  usage(argv[0]);
               const char * name = optarg;
               strcpy(dev_dir_, name);
            }
            break;
         case 't':
            {
               if (template_file_[0])
                  usage(argv[0]);
               const char * name = optarg;
               strcpy(template_file_, name);
            }
            break;
         default:
            usage(argv[0]);
      }
   }
   if ((config_file_[0] != 0) && (template_file_[0] != 0)) {
      printf("Only one of -i and -t options can be used at a time\n");
      usage(argv[0]);
   }
   if ((config_file_[0] == 0) && (template_file_[0] == 0)) {
      usage(argv[0]);
   }
   if (dev_dir_[0] == 0) {
      usage(argv[0]);
   }
   printf("config:     %s\n", config_file_[0] ? config_file_ : "------");
   printf("template:   %s\n", template_file_[0] ? template_file_ : "------");
   printf("dev dir:    %s\n", dev_dir_);
   printf("\n");
}

// command line
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// file input and output

static void write_template_file(void)
{
   FILE *fp = fopen(template_file_, "w");
   if (!fp) {
      printf("Unable to open '%s' for writing\n", template_file_);
      return;
   }
   fprintf(fp, "# Configuration file for softiron correction. \n");
   fprintf(fp, "version %.1f\n", (double) SUPPORTED_VERSION);
   fprintf(fp, "\n");
   fprintf(fp, "# Calculating softiron correction should be done in three\n");
   fprintf(fp, "# stages:\n");
   fprintf(fp, "# First, get a data file of raw MAG output, generated by\n");
   fprintf(fp, "#    's2'. The device's scale, offset and softiron config\n");
   fprintf(fp, "#    files should be deleted or set to null (ie, scale=1,\n");
   fprintf(fp, "#    offset=0, softiron=identity).\n");
   fprintf(fp, "#    NOTE: when generating data file, each axis should be\n");
   fprintf(fp, "#       rotated in such a way to achieve max response (ie,\n");
   fprintf(fp, "#       each axis should align with earth magnetic field \n");
   fprintf(fp, "#       vector, both positively and negatively)\n");
   fprintf(fp, "# Second, calculate hard-iron offset. To do this, run\n");
   fprintf(fp, "#    plot_mag.py and note the offsets for each axis. Add \n");
   fprintf(fp, "#    those offsets to the hard-iron section below\n");
   fprintf(fp, "# Third, determine axis rotations to align elliptical\n");
   fprintf(fp, "#    response patterns with XYZ axes. This is an iterative\n");
   fprintf(fp, "#    process:\n");
   fprintf(fp, "#    a) run 'calc_softiron.py' on the config file\n");
   fprintf(fp, "#    b) run 'softiron' on the raw data file, using '-p'\n");
   fprintf(fp, "#    c) run 'plot_mag.py' on softiron's output\n");
   fprintf(fp, "#    d) repeat until elliptical mag responses are aligned \n");
   fprintf(fp, "#       with XYZ axes from each perspective (xy, xz, yz)\n");
   fprintf(fp, "# Fourth, set scale as max value rotated response makes\n");
   fprintf(fp, "#    on each axis (eg, output from 'plot_mag.py'\n");
   fprintf(fp, "\n");
   fprintf(fp, "# host name\n");
   fprintf(fp, "gopher\n");
   fprintf(fp, "\n");
   fprintf(fp, "# device name\n");
   fprintf(fp, "lis3mdl\n");
   fprintf(fp, "\n");
   fprintf(fp, "# expected Gauss response at location of configuration\n");
   fprintf(fp, "#    (Seattle area is ~0.54 Gauss)\n");
   fprintf(fp, "0.54\n");
   fprintf(fp, "\n");
   fprintf(fp, "# Z rotation in XY plot in degrees\n");
   fprintf(fp, " 0.0\n");
   fprintf(fp, "# Y rotation in ZX plot in degrees\n");
   fprintf(fp, " 0.0\n");
   fprintf(fp, "# X rotation in YZ plot in degrees\n");
   fprintf(fp, " 0.0\n");
   fprintf(fp, "\n");
   fprintf(fp, "# scale (length of max XYZ after rotation)\n");
   fprintf(fp, " 1 1 1\n");
   fprintf(fp, "\n");
   fprintf(fp, "# order to apply rotations from descriptions\n");
   fprintf(fp, "zxy\n");
   fprintf(fp, "\n");
   fprintf(fp, "# Hard iron offset for x, y and z axes\n");
   fprintf(fp, " 0.0 0.0 0.0\n");
   fclose(fp);
}


static void init_value_by_string(double *val, char *line)
{
   errno = 0;
   char *str = line;
   *val = strtof(str, &str);
   if (errno != 0) {
      printf("Value parse error in line '%s'\n", line);
      exit(1);
   }
}

static void init_vector_by_string(vector_type *vec, char *line)
{
   errno = 0;
   char *str = line;
   vec->v[0] = strtof(str, &str);
   vec->v[1] = strtof(str, &str);
   vec->v[2] = strtof(str, &str);
   if (errno != 0) {
      printf("Vector parse error in line '%s'\n", line);
      exit(1);
   }
}

static void verify_version(char *line)
{
   char buf[256];
   strncpy(buf, line, sizeof(buf));
   char *str = buf;
   char *tok = strtok(str, " \t:");
   if (strcmp(tok, "version") != 0) {
      printf("Expected first field to be 'version'. Read '%s'. Bailing out\n",
            line);
      exit(1);
   }
   //
   errno = 0;
   tok = strtok(NULL, " \t:");
   double vers = strtof(tok, NULL);
   if (errno != 0) {
      printf("Version parse error in line '%s'\n", line);
      exit(1);
   }
   if (fabs(vers - SUPPORTED_VERSION) > 0.0001) {
      printf("Unsupported version. Only %.1f is supported. File is "
            "version %.1f\n", (double) SUPPORTED_VERSION, vers);
      exit(1);
   }
}


static void read_config_file(void)
{
   static char *lineptr = NULL;
   static size_t ptr_size = 0;
   enum { VERSION,
         HOST,
         DEVICE,
         GAUSS,
         Z_ROT,
         Y_ROT,
         X_ROT,
         SCALE,
         ORDER,
         OFFSET,
         DONE
   } state = VERSION;
   FILE *fp = fopen(config_file_, "r");
   if (!fp) {
      printf("Failed to open '%s' for reading\n", config_file_);
      return;
   }
   while (getline(&lineptr, &ptr_size, fp) > 0) {
      char *line = trim_whitespace(lineptr);
      if ((line == NULL) || (line[0] == '#')) {
         continue;
      }
      switch (state) {
         case VERSION:
            verify_version(line);
            state = HOST;
            break;
         case HOST:
            strcpy(host_name_, line);
            printf("Read host name '%s'\n", host_name_);
            state = DEVICE;
            break;
         case DEVICE:
            strcpy(device_name_, line);
            printf("Read device '%s'\n", device_name_);
            state = GAUSS;
            break;
         case GAUSS:
            init_value_by_string(&gauss_, line);
            printf("Read Gauss %.3f\n", (double) gauss_);
            state = Z_ROT;
            break;
         case Z_ROT:
            init_value_by_string(&rot_.v[2], line);
            state = Y_ROT;
            break;
         case Y_ROT:
            init_value_by_string(&rot_.v[1], line);
            state = X_ROT;
            break;
         case X_ROT:
            init_value_by_string(&rot_.v[0], line);
            print_vec(&rot_, "Axes rotations");
            state = SCALE;
            break;
         case SCALE:
            init_vector_by_string(&scale_, line);
            print_vec(&scale_, "Scale values");
            for (uint32_t i=0; i<3; i++) {
               if (scale_.v[i] == 0.0) {
                  printf("Cannot have zero scale (%s)\n", line);
                  exit(1);
               }
               scale_.v[i] = gauss_ / scale_.v[i];
            }
            print_vec(&scale_, "-> converted scale");
            state = ORDER;
            break;
         case ORDER:
            strcpy(matrix_order_, line);
            printf("Matrix order: '%s'\n", matrix_order_);
            state = OFFSET;
            break;
         case OFFSET:
            init_vector_by_string(&offset_, line);
            print_vec(&offset_, "Hard iron offset");
            state = DONE;
            return;
            break;
         default:
            printf("Intneral error -- unknown state\n");
            exit(1);
            break;
      };
   }
}

// file output

static void save_softiron(void)
{
   char buf[STR_LEN];
   assert(dev_dir_[0] != 0);
   build_path_string2(dev_dir_, host_name_, "sensors/i2c/", device_name_,
         "modality/mag/softiron", buf, STR_LEN);
   FILE *fp = fopen(buf, "w");
   if (!fp) {
      perror("Error writing softiron file");
      printf("Failed to open '%s' for writing\n", buf);
      exit(1);
   }
   fprintf(fp, "# softiron rotation matrix -- autogenerated by "
         "calc_softiron\n");
   fprintf(fp, "%.4f %.4f %.4f\n", (double) softiron_.m[0],
         (double) softiron_.m[1], (double) softiron_.m[2]);
   fprintf(fp, "%.4f %.4f %.4f\n", (double) softiron_.m[3],
         (double) softiron_.m[4], (double) softiron_.m[5]);
   fprintf(fp, "%.4f %.4f %.4f\n", (double) softiron_.m[6],
         (double) softiron_.m[7], (double) softiron_.m[8]);
   fclose(fp);
   printf("Created file %s\n", buf);
}

static void save_offset(void)
{
   char buf[STR_LEN];
   build_path_string2(dev_dir_, host_name_, "sensors/i2c/", device_name_,
         "modality/mag/offset", buf, STR_LEN);
   FILE *fp = fopen(buf, "w");
   if (!fp) {
      perror("Error writing offset file");
      printf("Failed to open '%s' for writing\n", buf);
      exit(1);
   }
   fprintf(fp, "# hard iron offset for x, y and z axes (after "
         "axis_alignment applied)\n");
   fprintf(fp, "%.4f %.4f %.4f\n", (double) offset_.v[0],
         (double) offset_.v[1], (double) offset_.v[2]);
   fclose(fp);
   printf("Created file %s\n", buf);
}

static void save_scale(void)
{
   char buf[STR_LEN];
   build_path_string2(dev_dir_, host_name_, "sensors/i2c/", device_name_,
         "modality/mag/scale", buf, STR_LEN);
   FILE *fp = fopen(buf, "w");
   if (!fp) {
      perror("Error writing scale file");
      printf("Failed to open '%s' for writing\n", buf);
      exit(1);
   }
   fprintf(fp, "# scale for x, y and z axes (after axis_alignment applied)\n");
   fprintf(fp, "# autogenerated by calc_softiron\n");
   fprintf(fp, "%.4f %.4f %.4f\n", (double) scale_.v[0],
         (double) scale_.v[1], (double) scale_.v[2]);
   fclose(fp);
   printf("Created file %s\n", buf);
}

// file input and output
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// calculations

//static void calculate_scale(void)
//{
//   // the long,short axes are measured and the rotation to bring each
//   //    to the XYZ axes are provided. for the axes that correspond
//   //    to each of XYZ, find the largest value for XYZ (this will be
//   //    the max of one long and one short axis for each of XYZ)
//   vector_type max;
//   max.v[0] = fmaxf(xy_description_.v[1], zx_description_.v[2]);
//   max.v[2] = fmaxf(zx_description_.v[1], yz_description_.v[2]);
//   max.v[1] = fmaxf(yz_description_.v[1], xy_description_.v[2]);
//   if ((max.v[0] == 0.0f) || (max.v[1] == 0.0f) || (max.v[2] == 0.0f)) {
//      printf("Error -- zero length reported for one or more axes\n");
//      print_vec(&max, "Axes maximums");
//      exit(1);
//   }
//   double largest = fmaxf(max.v[0], max.v[1]);
//   largest = fmaxf(largest, max.v[2]);
//   for (uint32_t i=0; i<3; i++) {
//      scale_.v[i] = largest / max.v[i];
//   }
//}

static void calculate_softiron(void)
{
   //identity_matrix(&softiron_);
   const vector_type x_axis = { .v = { 1.0f, 0.0f, 0.0f } };
   const vector_type y_axis = { .v = { 0.0f, 1.0f, 0.0f } };
   const vector_type z_axis = { .v = { 0.0f, 0.0f, 1.0f } };
   matrix_type x_rot, y_rot, z_rot, tmp;
   degree_type x_deg = { .degrees = rot_.v[0] };
   degree_type y_deg = { .degrees = rot_.v[1] };
   degree_type z_deg = { .degrees = rot_.v[2] };
   axis_angle_to_rotation_matrix(&x_axis, x_deg, &x_rot);
   axis_angle_to_rotation_matrix(&y_axis, y_deg, &y_rot);
   axis_angle_to_rotation_matrix(&z_axis, z_deg, &z_rot);
   identity_matrix(&softiron_);
   // apply rotations in specified order
   // to right-multiply matrices, transpose them
   matrix_transpose(&x_rot);
   matrix_transpose(&y_rot);
   matrix_transpose(&z_rot);
   char *str = matrix_order_;
   while (*str != 0) {
      switch(*str++) {
         case 'x':
         case 'X':
            mult_matrix(&softiron_, &x_rot, &tmp);
            copy_matrix(&tmp, &softiron_);
print_mat(&softiron_, "new rot matrix, after X rotation");
            break;
         case 'y':
         case 'Y':
            mult_matrix(&softiron_, &y_rot, &tmp);
            copy_matrix(&tmp, &softiron_);
print_mat(&softiron_, "new rot matrix, after Y rotation");
            break;
         case 'z':
         case 'Z':
            mult_matrix(&softiron_, &z_rot, &tmp);
            copy_matrix(&tmp, &softiron_);
print_mat(&softiron_, "new rot matrix, after Z rotation");
            break;
         default:
            printf("Unrecognized rotation order: '%s'\n", matrix_order_);
            exit(1);
      };
   }
   // transpose output back to standard form
   matrix_transpose(&softiron_);
}

//static void calculate_softiron(void)
//{
//   //identity_matrix(&softiron_);
//   const vector_type x_axis = { .v = { 1.0f, 0.0f, 0.0f } };
//   const vector_type y_axis = { .v = { 0.0f, 1.0f, 0.0f } };
//   const vector_type z_axis = { .v = { 0.0f, 0.0f, 1.0f } };
//   vector_type result;
//   vector_type axis;
//   // descriptions provide gyro-like rotation. this is the opposite
//   //    of rotation matrix rotations
//   axis.v[0] = -yz_description_.v[0];
//   axis.v[1] = -zx_description_.v[0];
//   axis.v[2] = -xy_description_.v[0];
//   degree_type theta = { .degrees = vector_len(&axis) };
//   //
//   rotate_vector_about_axis(&axis, &x_axis, theta, &result);
//   for (uint32_t i=0; i<3; i++) {
//      softiron_.m[i] = result.v[i];
//   }
//   rotate_vector_about_axis(&axis, &y_axis, theta, &result);
//   for (uint32_t i=0; i<3; i++) {
//      softiron_.m[3+i] = result.v[i];
//   }
//   rotate_vector_about_axis(&axis, &z_axis, theta, &result);
//   for (uint32_t i=0; i<3; i++) {
//      softiron_.m[6+i] = result.v[i];
//   }
//}

// calculations
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// entry

static void generate_configs(void)
{
   read_config_file();
   //calculate_scale();
   calculate_softiron();
   //
   save_scale();
   save_offset();
   save_softiron();
}

int main(int argc, char **argv){
   parse_command_line(argc, argv);
   if (template_file_[0]) {
      write_template_file();
   } else {
      generate_configs();
   }
   return 0;
}

